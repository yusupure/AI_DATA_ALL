#####创建数组#####
打开文件:
numpy.genfromtxt(文件名称，delimter=',',dtpye=str)
delimiter=数据的分隔符号，
dtype=数据信息的格式是什么可以为：字符，数字等
-----------------------------------------------------------------------------------------------------
1维数组np.array([1,2,3])
2维数组np.array([[i,i+1,i+2] for i in range(3)])
理解为:先从0开始0，0+1，0+2），(1,1+1,1+2)如此类推通过列表推导式生成二维数组
--------------------------------------------------------------------------------------------------------------
np.array:数组核心(必须数据为同一个类型数据，否则会强制转换为统一的类型)
np.shape:主要用于查看数据结构使用
-----------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------
#原生数组创建方式
np.arange(start = 1,stop= 10,step=2,dtype = int)开始数，结束数，步进，数据类型，递增数组方法
np.arange(10)与Python的range基本一致，目的是生成0-9的数字为整数
--------------------------------------------------------------------------------------------------------------
# 指定元素数量的均匀递增数据
np.linspace(1.,10.,10)生成1到10的float类型数据，第一为是开始数据，第二是结束数，第三只截止数重1开始到10的浮点数
--------------------------------------------------------------------------------------------------------------
#全0矩阵
np.zeros(shape=(3,4),dtype=float)创建一个为3行4列，0的浮点数float的矩阵
--------------------------------------------------------------------------------------------------------------
#全1矩阵
np.ones(shape=(3,4),dtype=float)创建一个为3行4列，0的浮点数float的矩阵
--------------------------------------------------------------------------------------------------------------
# 返回具有与给定数组相同的形状和类型的零数组
通过ONES创建的二位数组进行定数组方式
np.ones_like(全0或全1的矩阵值)
--------------------------------------------------------------------------------------------------------------
# 返回具有与给定数组相同的形状和类型的新随机数组
np.empty_like(a)
--------------------------------------------------------------------------------------------------------------
# 对角矩阵（对角数据分布）(获取与创建方法一致)
np.diag([1,2,3])          
效果array([[1, 0, 0],
          [0, 2, 0],
          [0, 0, 3]])
 --------------------------------------------------------------------------------------------------------------         
 # 获取矩阵对角元素
 np.diag([[1,2,3],   打印结果为1，5，9   
        [4,5,6],
        [7,8,9]])
 --------------------------------------------------------------------------------------------------------------       
# 获取矩阵偏移对角元素
np.diag([[1,2,3],
        [4,5,6],
        [7,8,9]],1)在最后添加位置数据，代表移动1个位置就是2，6。如此类推
--------------------------------------------------------------------------------------------------------------
# 幂零矩阵
np.eye(3)(创建一个对角元素的对角矩阵，偏移值默认1，其他填充为0 )
[[ 1.  0.  0.]
 [ 0.  1.  0.]
 [ 0.  0.  1.]]
--------------------------------------------------------------------------------------------------------------
######随机函数创建######
函数	解释
rand(d0,d1,…)	[0,1]均匀分布
randint(low,high,size)	[low,high)整数均匀分布
choice(a,size,replace,p)	指定数组指定概率分布
randn(d0,d1,…)	标准正态分布
--------------------------------------------------------------------------------------------------------------
#均匀分布
np.random.rand(3,4)随机创建3列4行随机数据(可以设置为4个维，3行，2列执行)(最终结果合计为1的)
[[ 0.04959596  0.53548165  0.33093489  0.16563774]
 [ 0.00939441  0.57617981  0.10515313  0.97560581]
 [ 0.58028803  0.09093189  0.38018664  0.96978455]]
--------------------------------------------------------------------------------------------------------------
#整数均匀分布
np.random.randint(2,size=(3,4))
array([[1, 0, 1, 0],
       [1, 1, 0, 1],
       [1, 1, 1, 0]])
--------------------------------------------------------------------------------------------------------------
#numpy.random.randn()  #numpy.random.randn(d0,d1,…,dn)
randn函数返回一个或一组样本，具有标准正态分布。
**************************************************************************************************************
注：标准正态分布介绍
标准正态分布—-standard normal distribution
标准正态分布又称为u分布，是以0为均值、以1为标准差的正态分布，记为N（0，1）。
**************************************************************************************************************
dn表格每个维度
返回值为指定维度的array
np.random.randn(2,4)两个表格，4个维度
np.random.randn(4,3,2)4个表格，3行，2列维度
--------------------------------------------------------------------------------------------------------------
#指定数组指定概率分布
up.random.choice(a, size=None, replace=True, p=None)
从给定的一维数组中生成随机数，如[1,2,3,4]概率位数与数组的位数必须一致否则报错
参数： a为一维数组类似数据或整数；size为数组维度；p为数组中的数据出现的概率
a为整数时，对应的一维数组为np.arange(a)
^参数p的长度与参数a的长度需要一致；
^参数p为概率，p里的数据之和应为1
np.random.choice([1,2,3,4],size=(3,4),replace=True,p=[0.1,0.2,0.3,0.4])
--------------------------------------------------------------------------------------------------------------
#numpy.random.randint(low, high=None, size=None, dtype=’l’)
.返回随机整数，范围区间为[low,high），包含low，不包含high
.参数：low为最小值，high为最大值，size为数组维度大小，dtype为数据类型，默认的数据类型是np.int
.high没有填写时，默认生成随机数的范围是[0，low)
$设置LOW最少值，设置high最大值，如果不设置最大值默认Low当前值为最大值，size维度的大小就是list内含的数量，dtype='l低h高'
--------------------------------------------------------------------------------------------------------------
#生成[0,1)之间的浮点数(size=设置维度及列)
numpy.random.random_sample(size=None)
numpy.random.random(size=None)
numpy.random.ranf(size=None)
numpy.random.sample(size=None)
--------------------------------------------------------------------------------------------------------------
#numpy.random.seed()
np.random.seed()的作用：使得随机数据可预测。
样例：np.random.seed("可设置随机数次数") 
创建随机数：b=np.random.rand(5) 打印样例
当我们设置相同的seed，每次生成的随机数相同。如果不设置seed，则每次会生成不同的随机数
--------------------------------------------------------------------------------------------------------------.
# 更改数据类型，返回新数组
a.astype(float)
# 如果在reshape操作中将维度指定为-1，则会自动计算其他维度：
print a.reshape((3,-1))
# 原地修改原数组的形状
print a.resize((2,6))
# 阵列展开为向量 'C', 'F', 'A', or 'K'
a.ravel('A')结果：[2 1 1 0 2 2 1 0 0 0 2 2]
--------------------------------------------------------------------------------------------------------------
np.genfromtxt("文件名称",delimiter="分割符号",dtype=字符类型)
注：若需要在被文件夹中提取文件，则需要填写全部路径
--------------------------------------------------------------------------------------------------------------
第10课
--------------------------------------------------------------------------------------------------------------
#通过list取值方法获取数据
例如a[1,3]就代表第一行里面的数据，第三个数据
#切片方式
例如a[1:3]1到3里面数据
#取数按列取数
a[:,1] 代表所有的数据，获取第一列内的数据
#获取多列数据方式
a[:,0:2]就是0到1两列的数据
a[1:3,0:2]某行某列数据.
--------------------------------------------------------------------------------------------------------------
#判断处理bool
a==XX返回TURE FLASH
#获取值的方式
b=np.array([5,10,15,20])
a= (b==10)
方法1，b[a]查找匹配的值
矩阵方法
m=np.array([[5,10,15],[20,25,30],[35,40,45]])
v=(m[:,1]==25)第二行里面所有数据，是否等于25
方法2，m[v,:]打印b内里含有查询数据的那一列的数据，适用于矩阵操作
意思是M里面的v是查到的参数匹配这个行参数里面的所有参数
----------------------------------------------------------------------------------------------------
11课矩阵基础**********************************
#判断操作符号
&与的关系
|或的关系
min大小值
max大小值
sum求和函数
#a.sum(axis=1)行维度求和
#a.sum(axis=0)列维度求和
--------------------------------------------------------------------------------------------------------------
#常规方式
np.arange(15)[1,2,3,4,5,6,7,8,]
#变换方式
np.arange(15).reshape(3,5)把15个数据转换成3行，4列的数据
--------------------------------------------------------------------------------------------------------------
np.linspace(0,2*pi,100)起始值0，终点值是2*pi(3.14-6.28),平均获取100个值，把100平分到100个值里面，
--------------------------------------------------------------------------------------------------------------
np.ravel()把一个矩阵转换为一个List向量状态
np.hstack((a,b))合并两个矩阵的数据变为一个矩阵，但行列不变(横向处理)
a=np.floor(10*np.random.random((2,2)))
[[ 8.  8.]
 [ 2.  0.]]
b=np.floor(10*np.random.random((2,2)))
[[ 0.  5.]
 [ 4.  1.]]
np.hstack((a,b,c))
[[ 8.  8.  0.  5.]
 [ 2.  0.  4.  1.]]
 把两个矩阵数据合并为2行2列数据合并为一个2行4列数据。数据来源是通过合并方式实行（增加列数）
np.vstack((a,b))合并两个矩阵的数据变为一个矩阵，但行列不变(纵向处理)（增加行数）
[[ 8.  8.]
 [ 2.  0.]
 [ 0.  5.]
 [ 4.  1.]]
--------------------------------------------------------------------------------------------------------------
切分处理
np.hsplit(a,3)进行用行进行切分，三代表切分成多少份数据
b=np.floor(10*np.random.random((2,12)))
np.hsplit(a,(3,4))对位置进行才分，就是在前三个才分，第四个才分，然后剩下在拆分成1份，当然这个不能改变他们默认2行的
设置。
c=np.floor(10*np.random.random((12,2)))
np.vsplit(a,3)平均拆分成三分
--------------------------------------------------------------------------------------------------------------                    
#复制
如果a=b的内容那么代表a,b共用一个值只是名字不一样
#浅复制View()大家共一套值
c=a.view()
用is来判读两者的值是否一致
#深复制copy()每个数据都独有的关系，没有任何关系的
c=a.copy()
--------------------------------------------------------------------------------------------------------------
#需找索引中最大的一个值argmax
需找每一列的最大值（data.argmax(axis=0)）的索引
data[a,range(data.shape[1]))]
--------------------------------------------------------------------------------------------------------------
#对数据进行扩展
np.arange(0,40,10)0到40的array步调为10
b=np.tile(a,(3,5))行变成三倍和数据列变成5倍
#排序
np.array([3,2,5,1]，[5,6,8,1])
b=np.sort(a,axis=1)对行进行从小到大排序
np.array([3,2,5,1])
b=np.argsort(a)求一个最小值的索引
作为新的索引来传入a并进行获取。就获取排序后的结果，a[b]
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
